#!/bin/bash

#----------------------------------------------------------------------
#                                FUNCTIONS
#----------------------------------------------------------------------

log() {
    cat >/var/log/umbrella-install.log
}

check() {
    if [ $1 -eq 0 ]; then
        echo ok
    else
        echo fail
        if [ -n "$2" ]; then
            echo -e "$2"
        else
            echo '        ------------------- LOG OF THE LAST STEP -------------------'
            cat /var/log/umbrella-install.log
            echo '        ------------------------------------------------------------'
        fi
        exit 1
    fi
}

nanogenshi() {
    if [[ -z "${dept_name}" ]]; then
        dept_delfalse='/{% if dept_name is not None %}/,/{% end %}/d'
        dept_rendertrue='/{% if dept_name is None %}/,/{% end %}/ { /{% if dept_name is None %}/d; /{% end %}/d }'
        dept_replace=''
    else
        dept_delfalse='/{% if dept_name is None %}/,/{% end %}/d'
        dept_rendertrue='/{% if dept_name is not None %}/,/{% end %}/ { /{% if dept_name is not None %}/d; /{% end %}/d }'
        dept_replace="s/\${dept_name[^}]*}/${dept_name//\'/\\\\\\\'}/g"
    fi
    sed -e "${dept_delfalse}" -e "${dept_rendertrue}" -e "${dept_replace}" \
        -e '/{% python/,/%}/d' \
        -e "/{% if 'ubuntu-bionic' in metadata.groups %}/,/{% end %}/d" \
        -e "/{% if 'ubuntu-bionic' not in metadata.groups %}/,/{% end %}/ { /{% if 'ubuntu-bionic' not in metadata.groups %}/d; /{% end %}/d }" \
        -e "s/\${state[^}]*}/${state//\'/\\\\\\\'}/g" \
        -e "s/\${location[^}]*}/${location//\'/\\\\\\\'}/g" \
        -e "s/\${long_name[^}]*}/${long_name//\'/\\\\\\\'}/g" \
        -e "s/\${country_code[^}]*}/${country_code//\'/\\\\\\\'}/g" \
        -e "s/\${domain_name[^}]*}/${domain_name}/g" \
        -e "s/\${realm_name[^}]*}/${realm_name}/g" \
        -e "s/\${metadata.Properties\['umbrella_keys.xml'\].xdata.find('bcfg2_pass').text}/${bcfg2_pass}/g" \
        -e "s/\${metadata.Properties\['umbrella_keys.xml'\].xdata.find('CA_pass').text}/${CA_pass}/g" \
        -e "s/\${metadata.Properties\['umbrella_keys.xml'\].xdata.find('bcfg2_reports_db_name').text}/${bcfg2_db_name}/g" \
        -e "s/\${metadata.Properties\['umbrella_keys.xml'\].xdata.find('bcfg2_reports_db_user').text}/${bcfg2_db_user}/g" \
        -e "s/\${metadata.Properties\['umbrella_keys.xml'\].xdata.find('bcfg2_reports_db_pass').text}/${bcfg2_db_pass}/g" \
        -e 's/\$\$/\$/g' \
        -e "s|/var/lib/bcfg2|${UMBRELLADIR}|g" \
        -e "s|/etc/ssl/certs/bcfg2ca.pem|${TMPINSTALLDIR}/CA/certs/bcfg2ca.crt|g" \
        -e "s|/etc/pki|${TMPINSTALLDIR}|g"
}

# In the distributed version, this variable should be unset. It allows to add another debian
# repository into the pool, which is useful when developing the new Umbrella version with
# packages not yet published in the main repository.
DEBS_OVERLAY=/home/test/debs
if [ ! -d "${DEBS_OVERLAY}" ]; then
    unset DEBS_OVERLAY
fi

# the distribution version
source /etc/lsb-release

# command definitions
APT_GET="eatmydata apt-get"
APT_GET_UPDATE="env DEBIAN_FRONTEND=noninteractive ${APT_GET} update"
APT_GET_UPGRADE="env DEBIAN_FRONTEND=noninteractive ${APT_GET} upgrade --assume-yes"
APT_GET_INSTALL="env DEBIAN_FRONTEND=noninteractive ${APT_GET} install --assume-yes"
APT_GET_PURGE="env DEBIAN_FRONTEND=noninteractive ${APT_GET} purge --assume-yes"
APT_GET_AUTOREMOVE="env DEBIAN_FRONTEND=noninteractive ${APT_GET} autoremove --assume-yes"
BCFG2="eatmydata bcfg2"

# XML file paths
UMBRELLA_XML="./umbrella.xml"
UMBRELLA_KEYS_XML="./umbrella_keys.xml"

# temporary locations
TMPINSTALLDIR="/root/umbrella"
UMBRELLADIR="${TMPINSTALLDIR}/bcfg2"
FLAGSDIR="${TMPINSTALLDIR}/flags"
mkdir -p ${FLAGSDIR}
SSLCADIR="${TMPINSTALLDIR}/CA"


#----------------------------------------------------------------------
#                                  MAIN
#----------------------------------------------------------------------

GIT_USER=""
GIT_PASS=""

# parse the parameters
while [[ $# -gt 0 ]]
do
key=$1
case $key in
    -h|--help)
    cat <<EOF

This script installs Umbrella Linux system to a set of LXD containers.

To install, place the set of XML files, describing its configuration
into the current directory. And run

  umbrella-install [-u <git-username>] | [-b <branch-name>] -U <repository-URL>

The -u option allows to use the private Umbrella Linux development git
repository and will prompt for the repository password. It does not prompt
for the password if ~/.netrc file is already present. By default public
Umbrella Linux repository is used.

With the -U option the installer clones the bcfg2 repository from the given
URL. Using -b option it is also possible to specify the branch to clone.

EOF
    exit 0
    ;;
    -u)
    GIT_USER=$2
    shift
    shift
    if [ ! -f ~/.netrc ]; then
      echo -n "GIT repository Password: "
      read -s GIT_PASS
      echo
    fi
    ;;
    -U)
    GIT_URL=$2
    shift
    shift
    ;;
    -b)
    GIT_BRANCH=$2
    shift
    shift
esac
done

if [ -n "$GIT_USER" -a -n "$GIT_BRANCH" ]; then
    cat <<EOF
It is impossible to specify -u and -b options together. Installing from the private repository
always uses the master branch.
EOF
    exit 1
fi

if [ -z "$GIT_URL" -a -n "$GIT_BRANCH" ]; then
    cat <<EOF
It is impossible to specify -b option alone. Installing from the public repository always uses
the master branch.
EOF
    exit 1
fi


if [ -n "$GIT_USER" -a -n "$GIT_URL" ]; then
    cat <<EOF
It is -u and -U options together are not supported. If you specify the full repository URL,
you can always embed the username.
EOF
    exit 1
fi

cat << EOF
Welcome to the Umbrella Linux installer !

                         (c) 2016-2023 Konstantin L. Metlov <metlov@donfti.ru>
                         as well as others, listed in the AUTHORS file.
                         Umbrella Linux (including this installer) is avaiable
                         under the terms of GNU General Public License v3 or
                         later. NO WARRANTY OF ANY KIND IS PROVIDED !!!

After the instaler successfully completes, this fresh mini-Ubuntu system
will become an LXD host with Umbrella Linux containers defined as per
configuration in *.xml files, supplied in the current directory.

You will find last command protocol in /var/log/umbrella-install.log

EOF

echo -n "Checking the script is run by the root user... "; ( set -e; set -o xtrace;
     [ "$EUID" -eq "0" ]
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Checking the distribution version... "; ( set -e; set -o xtrace;
    [ "$DISTRIB_CODENAME" == "jammy" ]
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Ensuring eatmydata is available... "; ( set -e; set -o xtrace;
    env DEBIAN_FRONTEND=noninteractive apt-get install --assume-yes eatmydata
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Ensuring no snaps are installed... "; ( set -e; set -o xtrace;
    snap list --all | awk '/disabled/{print $1, $3}' |
    while read snapname revision; do
        snap remove "$snapname" --revision="$revision"
    done
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Removing unnecessary packages... "; ( set -e; set -o xtrace;
    ${APT_GET_PURGE} needrestart uuid-runtime mlocate snapd
    cat <<- EOF >/etc/apt/preferences.d/no-snap.pref
	# To install snapd, specify its version with 'apt install snapd=VERSION'
	# where VERSION is the version of the snapd package you want to install.
	Package: snapd
	Pin: release a=*
	Pin-Priority: -10
	EOF
    ${APT_GET_AUTOREMOVE}
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Upgrading all packages to their current versions... "; ( set -e; set -o xtrace;
    if [ -d "$DEBS_OVERLAY" ]; then
        echo "deb [trusted=yes] file://${DEBS_OVERLAY} ./" >/etc/apt/sources.list.d/debs.list
    fi
    ${APT_GET_UPDATE}
    ${APT_GET_UPGRADE}
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Shifting the uid/gid of messagebus... "; ( set -e; set -o xtrace;
    groupmod -g 677 messagebus
    if [ ! `id -u messagebus` -eq 677 ]; then
        systemctl stop dbus
        systemctl kill dbus
        systemctl stop dbus.socket
        usermod -u 677 messagebus
    fi
    if [ -e /usr/lib/dbus-1.0/dbus-daemon-launch-helper ]; then
        chgrp messagebus /usr/lib/dbus-1.0/dbus-daemon-launch-helper
        chmod u+s /usr/lib/dbus-1.0/dbus-daemon-launch-helper
    fi
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Shifting the uid/gid of sshd... "; ( set -e; set -o xtrace;
    getent passwd sshd &>/dev/null && usermod -u 676 sshd
    getent passwd sshd &>/dev/null || \
        useradd -d /run/sshd -g nogroup -M -s /usr/sbin/nologin -u 676 sshd
    exit 0
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Next we need to install some packages... "; ( set -e; set -o xtrace;
    ${APT_GET_INSTALL} python3-lxml libxml2-utils git openssh-server \
                       bridge-utils dpkg-dev mmdebstrap gpm
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Check that sshd still has correct uid... "; ( set -e; set -o xtrace;
    sshd_user_uid=`id -u sshd`
    [ "$sshd_user_uid" -eq 676 ]
) 2>&1 | log; check ${PIPESTATUS[0]}

if [ ! -d "$UMBRELLADIR" ]; then
    echo -n "Checking out the Umbrella Linux repository to ${UMBRELLADIR} ... "; ( set -e; set -o xtrace;
        if [ -z "$GIT_USER" -a -z "$GIT_URL" ]; then
        # public repository
            git clone https://github.com/metlov/umbrella-linux.git "$UMBRELLADIR"
        elif [ -n "$GIT_URL" ]; then
            if [-z "$GIT_BRANCH" ]; then
                # cloning master branch from the specified URL.
                git clone "$GIT_URL" "$UMBRELLADIR"
            else
                # cloning the specified branch from the specified URL
                git clone "$GIT_URL" -b "$GIT_BRANCH" --single-branch "$UMBRELLADIR"
            fi
        else
# private repository
            if [ ! -f ~/.netrc ]; then
                cat >~/.netrc <<-EOF
			machine www.donfti.ru
			login $GIT_USER
			password $GIT_PASS
			EOF
            fi
            mkdir -p ~/git-certs/
            cat >~/git-certs/DonFTI.pem <<EOF
-----BEGIN CERTIFICATE-----
MIIGczCCBFugAwIBAgIJAIP2QmZguKTDMA0GCSqGSIb3DQEBCwUAMIHPMQswCQYD
VQQGEwJSVTEiMCAGA1UECAwZRG9uZXRzayBQZW9wbGUncyBSZXB1YmxpYzEQMA4G
A1UEBwwHRG9uZXRzazE1MDMGA1UECgwsRG9uZXRzayBJbnN0aXR1dGUgZm9yIFBo
eXNpY3MgYW5kIFRlY2hub2xvZ3kxFjAUBgNVBAsMDUlUIGRlcGFydG1lbnQxGTAX
BgNVBAMMEGNvbmZpZy5kb25mdGkucnUxIDAeBgkqhkiG9w0BCQEWEWl0YWRtaW5A
ZG9uZnRpLnJ1MB4XDTE3MDEyNDEzMTgyNloXDTM3MDExOTEzMTgyNlowgc8xCzAJ
BgNVBAYTAlJVMSIwIAYDVQQIDBlEb25ldHNrIFBlb3BsZSdzIFJlcHVibGljMRAw
DgYDVQQHDAdEb25ldHNrMTUwMwYDVQQKDCxEb25ldHNrIEluc3RpdHV0ZSBmb3Ig
UGh5c2ljcyBhbmQgVGVjaG5vbG9neTEWMBQGA1UECwwNSVQgZGVwYXJ0bWVudDEZ
MBcGA1UEAwwQY29uZmlnLmRvbmZ0aS5ydTEgMB4GCSqGSIb3DQEJARYRaXRhZG1p
bkBkb25mdGkucnUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC1tFdx
v3DmuK6jkrBxy/P7kYqDdC4cjCnowhr0aZCRWvdQDBx0jquAZVu8tJOdP8/4yYbg
GTqr7ALe364U2rauMQxrwtTTIHmjuf7XSE++QmGro3CFFO+Mts6PEORnSiomwPSK
hvmloUy+DZpS8bys0dtuyXztuKL34r9gvkT2pG3G83sfmrv/RHbHRaWBxlD7myCm
y6bPMJ71T0SjzlAgoAv8ZlIrpxAhssn3H1r0GJuVJYn6CC9JfVJpomZF49v2B8IN
nImV/I5R/66d+AfwdHf4tv3XQlIPwy1Vq1J8lRVqDWsGDl2phqhXbE3hFotV4QVi
Xrp6vMP80WZgVCuiNfYEUktg/9F02ezmC5sFTmNfZnV10ZGBfgJCZUt9UY6LktDD
KOtI0q+I4puVrl79x3Dn6nwDMDeD+pSDXo3vntEjqsTMrWnhkG0MLEymB6qyfugh
5KEU0ObYu9ZQAts1yCoVSLGrLGsnVUHYdnmW2lIoaBPyLzBvVXzkkvitpkWVZaKw
iiX/MdTc2y654i9zgBoC4zafEZKu+TOdg2jpA0q3SL5Gvtph/A1wC5XOLZoihygn
AMDE6GR1UzYkYrm3nTvgDtDys2UBpCV2hsghA3o0EaDeeZwox+xripQcDJwN4NMd
obvPGY3xCivR2tHTaquKvSCTDlEpT+/9fILVPQIDAQABo1AwTjAdBgNVHQ4EFgQU
+MC+fpgwaZ4l+vJ2OVOFhl9b5BQwHwYDVR0jBBgwFoAU+MC+fpgwaZ4l+vJ2OVOF
hl9b5BQwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAgEAWIGZf5foOMFG
YqhO6LDfQeFlLVgutSF93TR7YMiAc898dlSqDoJTkkfaq19/OR095AK0E5uqrtQO
JtUCFKL+fsM2JqXY8rzb9sCUDxQ3sCpttH2tNhneWK4jmGKyGRaOLZahcjf2tLIf
2VgfvPbbhrOjN3szjvG4YVmub6acTin9VtYEgj6/GOxt83uz/cCc1vxTeiWGaCk1
WqgsIn8fQfjqPuEbUHQfFWDtxpOwLHgZLBCw4Qonn0+hlK8DPkJ+pl6goXeebZGh
3JzeAllNvZiuplvSIGFap7DpbIVgkDaSy14fmIgqSm0PRp8+aTy9/hCU5xPRbGtB
IydZc8am2dVLzsaPK2Lr3qAgyu5Twz2o1qCmDWW7rB9Zg9i/c+k8RtXVJkBJsTIm
MfPj41e83PmIbo+60CggY2//fMsoXR5IvP6c46e7K5YKgzvP9NcHzAqYrq0KSmoT
4NgWOUCYMOMeHLEQFSa0qTFfxT8jtOUgoH4oJE5ICVeYo6u18fNpD1dcS8IVsCTM
JP3KOOjiTPJhEuD4+3tfO/AI4fnZjXxJKWttBVrHojq9oVxXTW5UPSSYQIeqZQA9
D8z34POjikft0/MEGz5TmZgK+HmEo0tZGm8VX4gcVYfnxyLWPJn2Tt0Jz/kCofHI
eGRmR5ZvAvrjEhQiLXhUBF6bI5xbTwc=
-----END CERTIFICATE-----
EOF
            cat >~/.gitconfig <<-EOF
		[http]
		sslCAInfo = ~/git-certs/DonFTI.pem
		EOF
	    git clone https://www.donfti.ru/umbrella.git "$UMBRELLADIR"
        fi
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

xml_req_files="firewall.xml lan_topology.xml mailaliases.xml organization.xml umbrella.xml usbdev.xml vpn.xml"
if ! ls $xml_req_files &>/dev/null; then
    echo "The customized Umbrella configuration xml files are absent in the current"
    echo "directory. Copying the defaults:"
    echo
    for xml_file in $xml_req_files; do
        if [ ! -f ./$xml_file ]; then
            echo "./${xml_file}"
            cp "$UMBRELLADIR/Documentation/installer/$xml_file" ./
        fi
    done
    echo
    echo "Please fill the templates with the data for your system and run this"
    echo "installer again. This defines the configuration of your whole new system !"
    echo "Be careful and consult manual (if available) or people who have some"
    echo "experience with Umbrella Linux."
    echo
    echo "You may also simply run the installer again to get a default demo system."
    exit 1
fi

if [ ! -f "${UMBRELLADIR}/Local/Rules/local-rules.xml" ]; then
    echo -n "Creating empty Local/Rules/local-rules.xml... "; ( set -e; set -o xtrace;
        echo -e "<Rules priority=\"0\">\n</Rules>" > ${UMBRELLADIR}/Local/Rules/local-rules.xml
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

echo -n "Validating the Umbrella Linux configuration XML files... "; ( set -e; set -o xtrace;
for xml_file in $xml_req_files; do
    xmllint --noout --schema "$UMBRELLADIR/Properties/${xml_file%.*}.xsd" ./$xml_file
done
) 2>&1 | log; check ${PIPESTATUS[0]}

echo -n "Checking that all the bridges are defined in vmhost definition... "; ( set -e; set -o xtrace;
    xmllint --xpath '//Properties//server[function="vmhost"]/extif/dev/text()' ${UMBRELLA_XML}
    xmllint --xpath '//Properties//server[function="vmhost"]/pubif/dev/text()' ${UMBRELLA_XML}
    xmllint --xpath '//Properties//server[function="vmhost"]/secif/dev/text()' ${UMBRELLA_XML}
    xmllint --xpath '//Properties//server[function="vmhost"]/DMZif/dev/text()' ${UMBRELLA_XML}
) 2>&1 | log; check ${PIPESTATUS[0]}

tmpfile=$(mktemp)
echo -n "Pulling the network configuration and other data from umbrella.xml... "; ( set -e; set -o xtrace;
    cdr2mask ()
    {
        # Number of args to shift, 255..255, first non-255 byte, zeroes
        set -- $(( 5 - ($1 / 8) )) 255 255 255 255 $(( (255 << (8 - ($1 % 8))) & 255 )) 0 0 0
        [ $1 -gt 1 ] && shift $1 || shift
        echo ${1-0}.${2-0}.${3-0}.${4-0}
    }

    netparams ()
    {
        fromxml=`xmllint --xpath "//Properties//${1}net/text()" ${UMBRELLA_XML}`
        echo ${1}_xml=${fromxml}
        echo ${1}_network=`dirname $fromxml`
        cidr=`basename $fromxml`
        echo ${1}_cidr=$cidr
        echo ${1}_netmask=`cdr2mask $cidr`
    }

    # get bridge names from umbrella.xml
    echo ext_br=`xmllint --xpath '//Properties//server[function="vmhost"]/extif/dev/text()' ${UMBRELLA_XML}` >>${tmpfile}
    echo pub_br=`xmllint --xpath '//Properties//server[function="vmhost"]/pubif/dev/text()' ${UMBRELLA_XML}` >>${tmpfile}
    echo sec_br=`xmllint --xpath '//Properties//server[function="vmhost"]/secif/dev/text()' ${UMBRELLA_XML}` >>${tmpfile}
    echo DMZ_br=`xmllint --xpath '//Properties//server[function="vmhost"]/DMZif/dev/text()' ${UMBRELLA_XML}` >>${tmpfile}

    # get networks and compute netmasks
    netparams ext >>${tmpfile}
    netparams pub >>${tmpfile}
    netparams sec >>${tmpfile}
    netparams DMZ >>${tmpfile}

    # determine the external networking params
    echo ext_if=`xmllint --xpath '//Properties//server[function="router"]/extif/dev/text()' ${UMBRELLA_XML}` >>${tmpfile}
    echo ext_addr=`xmllint --xpath '//Properties//server[function="router"]/extif/ip/text()' ${UMBRELLA_XML}` >>${tmpfile}
    echo ext_mac=`xmllint --xpath '//Properties//server[function="router"]/extif/mac/text()' ${UMBRELLA_XML}` >>${tmpfile}
    echo ext_gateway=`xmllint --xpath '//Properties//server[function="router"]/extif/gateway/text()' ${UMBRELLA_XML}` >>${tmpfile}

    # get domain_name and other static parameters from umbrella.xml
    domain_name=`xmllint --xpath '(//Properties//domain)[1]/name/text()' ${UMBRELLA_XML}`
    echo domain_name=$domain_name >>${tmpfile}
    echo system_name=\"`xmllint --xpath '//Properties//system_name/text()' ${UMBRELLA_XML}`\" >>${tmpfile}
    echo realm_name=`echo $domain_name | tr a-z A-Z` >>${tmpfile}
    echo ldap_root=`echo "dc=$domain_name" | sed -e 's/\./,dc=/g'` >>${tmpfile}
    echo country_code=\"`xmllint --xpath '//Properties//country_code/text()' ${UMBRELLA_XML}`\" >>${tmpfile}
    echo state=\"`xmllint --xpath '//Properties//state/text()' ${UMBRELLA_XML}`\" >>${tmpfile}
    echo location=\"`xmllint --xpath '//Properties//location/text()' ${UMBRELLA_XML}`\" >>${tmpfile}
    echo long_name=\"`xmllint --xpath '//Properties//long_name/text()' ${UMBRELLA_XML}`\" >>${tmpfile}
    echo dept_name=\"`xmllint --xpath '//Properties//dept_name/text()' ${UMBRELLA_XML} 2>/dev/null`\" >>${tmpfile}

    # first admin username and all admin usernames
    echo first_admin=\"`xmllint --xpath '(//Properties//admin/text())[1]' ${UMBRELLA_XML}`\" >>${tmpfile}
    echo all_admins=\"`xmllint --xpath '//Properties//admin/text()' ${UMBRELLA_XML}`\" >>${tmpfile}

    # list of short names of all servers
    echo allservers=\"`xmllint --xpath '//Properties//server/name/text()' ${UMBRELLA_XML}`\" >>${tmpfile}

    # list of all server functions
    echo allfunctions=\"`xmllint --xpath '//Properties//server/function/text()' ${UMBRELLA_XML}`\" >>${tmpfile}

    function get_name() {
        xmllint --xpath "//Properties//server[function=\"${1}\"]/name/text()" ${UMBRELLA_XML} 2>/dev/null
    }
    function get_ip() {
        xmllint --xpath "//Properties//server[function=\"${1}\"]/${2}if/ip/text()" ${UMBRELLA_XML} 2>/dev/null
    }
    function get_mac() {
        xmllint --xpath "//Properties//server[function=\"${1}\"]/${2}if/mac/text()" ${UMBRELLA_XML} 2>/dev/null
    }
    function get_dev() {
        xmllint --xpath "//Properties//server[function=\"${1}\"]/${2}if/dev/text()" ${UMBRELLA_XML} 2>/dev/null
    }

    # retrieve the host names and ip addresses from umbrella.xml if defined
    echo router_hostname=`get_name router` >>${tmpfile}
    echo router_ext_ip=`get_ip router ext` >>${tmpfile}
    echo router_ext_mac=`get_mac router ext` >>${tmpfile}
    echo router_ext_dev=`get_dev router ext` >>${tmpfile}
    echo router_pub_ip=`get_ip router pub` >>${tmpfile}
    echo router_pub_mac=`get_mac router pub` >>${tmpfile}
    echo router_pub_dev=`get_dev router pub` >>${tmpfile}
    echo router_sec_ip=`get_ip router sec` >>${tmpfile}
    echo router_sec_mac=`get_mac router sec` >>${tmpfile}
    echo router_sec_dev=`get_dev router sec` >>${tmpfile}
    echo router_DMZ_ip=`get_ip router DMZ` >>${tmpfile}
    echo router_DMZ_mac=`get_mac router DMZ` >>${tmpfile}
    echo router_DMZ_dev=`get_dev router DMZ` >>${tmpfile}
    echo config_hostname=`get_name config` >>${tmpfile}
    echo config_pub_ip=`get_ip config pub` >>${tmpfile}
    echo config_pub_mac=`get_mac config pub` >>${tmpfile}
    echo config_pub_dev=`get_dev config pub` >>${tmpfile}
    echo vmhost_hostname=`get_name vmhost` >>${tmpfile}
    echo vmhost_pub_ip=`get_ip vmhost pub` >>${tmpfile}
    echo vmhost_ext_mac=`get_mac vmhost ext` >>${tmpfile}
    echo proxy_hostname=`get_name proxy` >>${tmpfile}
    echo proxy_pub_ip=`get_ip proxy pub` >>${tmpfile}
    echo proxy_pub_mac=`get_mac proxy pub` >>${tmpfile}
    echo proxy_pub_dev=`get_dev proxy pub` >>${tmpfile}
    echo nfs_hostname=`get_name nfs` >>${tmpfile}
    echo nfs_pub_ip=`get_ip nfs pub` >>${tmpfile}
    echo nfs_pub_mac=`get_mac nfs pub` >>${tmpfile}
    echo nfs_pub_dev=`get_dev nfs pub` >>${tmpfile}
    echo mail_hostname=`get_name mail` >>${tmpfile}
    echo mail_pub_ip=`get_ip mail pub` >>${tmpfile}
    echo mail_pub_mac=`get_mac mail pub` >>${tmpfile}
    echo mail_pub_dev=`get_dev mail pub` >>${tmpfile}
    echo ltsp_hostname=`get_name ltsp` >>${tmpfile}
    echo ltsp_pub_ip=`get_ip ltsp pub` >>${tmpfile}
    echo ltsp_pub_mac=`get_mac ltsp pub` >>${tmpfile}
    echo ltsp_pub_dev=`get_dev ltsp pub` >>${tmpfile}
    echo monitor_hostname=`get_name monitor` >>${tmpfile}
    echo monitor_pub_ip=`get_ip monitor pub` >>${tmpfile}
    echo monitor_pub_mac=`get_mac monitor pub` >>${tmpfile}
    echo monitor_pub_dev=`get_dev monitor pub` >>${tmpfile}
    echo backdoor_hostname=`get_name backdoor` >>${tmpfile}
    echo backdoor_pub_ip=`get_ip backdoor pub` >>${tmpfile}
    echo backdoor_pub_mac=`get_mac backdoor pub` >>${tmpfile}
    echo backdoor_pub_dev=`get_dev backdoor pub` >>${tmpfile}
    echo backdoor_ext_ip=`get_ip backdoor ext` >>${tmpfile}
    echo backdoor_ext_mac=`get_mac backdoor ext` >>${tmpfile}
    echo backdoor_ext_dev=`get_dev backdoor ext` >>${tmpfile}
    echo smtp_hostname=`get_name DMZsmtp` >>${tmpfile}
    echo smtp_DMZ_ip=`get_ip DMZsmtp DMZ` >>${tmpfile}
    echo smtp_DMZ_mac=`get_mac DMZsmtp DMZ` >>${tmpfile}
    echo smtp_DMZ_dev=`get_dev DMZsmtp DMZ` >>${tmpfile}
    echo www_hostname=`get_name DMZwww` >>${tmpfile}
    echo www_DMZ_ip=`get_ip DMZwww DMZ` >>${tmpfile}
    echo www_DMZ_mac=`get_mac DMZwww DMZ` >>${tmpfile}
    echo www_DMZ_dev=`get_dev DMZwww DMZ` >>${tmpfile}
    echo xmpp_hostname=`get_name DMZxmpp` >>${tmpfile}
    echo xmpp_DMZ_ip=`get_ip DMZxmpp DMZ` >>${tmpfile}
    echo xmpp_DMZ_mac=`get_mac DMZxmpp DMZ` >>${tmpfile}
    echo xmpp_DMZ_dev=`get_dev DMZxmpp DMZ` >>${tmpfile}
    echo vpn_hostname=`get_name DMZvpn` >>${tmpfile}
    echo vpn_DMZ_ip=`get_ip DMZvpn DMZ` >>${tmpfile}
    echo vpn_DMZ_mac=`get_mac DMZvpn DMZ` >>${tmpfile}
    echo vpn_DMZ_dev=`get_dev DMZvpn DMZ` >>${tmpfile}
) 2>&1 | log; check ${PIPESTATUS[0]}
source ${tmpfile}
rm -f ${tmpfile}

NETCONFFILE=/etc/netplan/01-netcfg.yaml
if ! grep -q '# Umbrella Installer Bridges Defined' ${NETCONFFILE} 2>/dev/null; then
    # if we haven't established the networking bridging yet
    echo -n "Checking that the networking definitions in umbrella.xml are correct... "; ( set -e; set -o xtrace;
        ext_addr_real=`ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}' | cut -f1  -d'/'`
        [ "$ext_addr" == "$ext_addr_real" ]
        ext_mac_real=` ip addr | grep 'state UP' -A1 | tail -n1  | awk '{print $2}'`
        [ "$ext_mac" == "$ext_mac_real" ]
        [ "$ext_mac" != "$vmhost_ext_mac" ]
        ext_if_real=`ip addr | awk '/state UP/ {print $2}' | sed 's/.$//'`
        [ "$ext_if" == "$ext_if_real" ]
        ext_network_real=`ip -o -f inet addr show "${ext_if}" | awk '/scope global/ {print $4}'`
        [ "$ext_addr/$ext_cidr" == "$ext_network_real" ]
        ext_gateway_real=`ip route list | awk ' /^default/ {print $3}'`
        [ "$ext_gateway" == "$ext_gateway_real" ]
        # checking that router has all the IPs defined
        [ -n "$router_ext_ip" ]
        [ -n "$router_pub_ip" ]
        [ -n "$router_sec_ip" ]
        [ -n "$router_DMZ_ip" ]
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

if [ -e ${UMBRELLA_KEYS_XML} ]; then
    echo -n "Validating the supplied umbrella_keys.xml... "; ( set -e; set -o xtrace;
      xml_file="${UMBRELLA_KEYS_XML}"
    xmllint --noout --schema "$UMBRELLADIR/Properties/${xml_file%.*}.xsd" ./$xml_file
    CA_pub=`xmllint --xpath '//Properties//CA_pub/text()' ${UMBRELLA_KEYS_XML}`
    CA_subj=`echo "${CA_pub}" | openssl x509 -noout -subject | sed 's/subject=//' | sed 's/ = /="/g' | sed "s|'|\\\'|g" | sed 's/, /"\n/g' | sed '$s/$/\"/'`
    eval $CA_subj
    [ "$C" == "$country_code" ]
    [ "$ST" == "$state" ]
    [ "$L" == "$location" ]
    [ "$O" == "$long_name" ]
    [ "$CN" == "${config_hostname}.${domain_name}" ]
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi


if [ ! -f "$SSLCADIR/index.txt" ]; then
    echo -n "Feeding the entropy pool... "; ( set -e; set -o xtrace;
        wget -q -O - 'https://www.random.org/cgi-bin/randbyte?nbytes=2048&format=f' >/dev/urandom
    ) 2>&1 | log; check ${PIPESTATUS[0]}

    echo -n "Initializing OpenSSL CA... "; ( set -e; set -o xtrace;
        rm -rf "$SSLCADIR"
        mkdir -p "$SSLCADIR/certs/" "$SSLCADIR/private/"
          # the next lines is a kind of nano-Genshi for openssl.cnf
    cat $UMBRELLADIR/Cfg/etc/pki/openssl.cnf/openssl.cnf.genshi | \
        nanogenshi >"${TMPINSTALLDIR}/openssl.cnf"

    certfile="${SSLCADIR}/certs/bcfg2ca.crt"
    keyfile="${SSLCADIR}/private/bcfg2ca.key"
    if [ -e ${UMBRELLA_KEYS_XML} ]; then
        # we take the CA certificate and the key from the supplied umbrella_keys.xml
        # file /etc/pki/CA/private/passkey.txt is not created in this case
        CA_pub=`xmllint --xpath '//Properties//CA_pub/text()' ${UMBRELLA_KEYS_XML}`
        CA_sec=`xmllint --xpath '//Properties//CA_sec/text()' ${UMBRELLA_KEYS_XML}`
        echo "${CA_pub}" > "${certfile}"
        echo "${CA_sec}" > "${keyfile}"
    else
        # we generate the new keypair and the passphrase
        passkey=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
        passkeyfile="${SSLCADIR}/private/passkey.txt"
        echo "${passkey}" > "${passkeyfile}"
        chown root:root "${passkeyfile}"
        chmod 700 "${passkeyfile}"
        if [[ -z "$dept_name" ]]; then
            dept="IT department"
        else
            dept=$dept_name
        fi
        subj="/C=${country_code}/ST=${state//\'/\\\'}/L=${location//\'/\\\'}/O=${long_name//\'/\\\'}/OU=${dept//\'/\\\\\'}/emailAddress=itadmin@${domain_name}/CN=${config_hostname}.${domain_name}"
        openssl_opts="-new -newkey rsa:3072 -nodes -batch -x509 -config ${TMPINSTALLDIR}/openssl.cnf -extensions v3_ca  -days 3650"
        openssl req $openssl_opts -subj "`echo $subj`" -passout file:${SSLCADIR}/private/passkey.txt -keyout $keyfile -out $certfile
    fi
    mkdir -p "${SSLCADIR}/newcerts"
    mkdir -p "${SSLCADIR}/crl"
    echo 1000 > "${SSLCADIR}/crlnumber"
    echo 01 > "${SSLCADIR}/serial"
    openssl rand -writerand ${TMPINSTALLDIR}/.rnd
    touch "${SSLCADIR}/index.txt"
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

if [ ! -e ${UMBRELLA_KEYS_XML} ]; then
    echo -n "Feeding the entropy pool... "; ( set -e; set -o xtrace;
        wget -q -O - 'https://www.random.org/cgi-bin/randbyte?nbytes=2048&format=f' >/dev/urandom
    ) 2>&1 | log; check ${PIPESTATUS[0]}

    echo -n "Creating the umbrella_keys.xml... "; ( set -e; set -o xtrace;
        CA_pub=`cat "${SSLCADIR}/certs/bcfg2ca.crt"`
        CA_sec=`cat "${SSLCADIR}/private/bcfg2ca.key"`
        CA_pass=`cat "${SSLCADIR}/private/passkey.txt"`
        DKIM_sec=`openssl genrsa 1024`
        DKIM_pub=`echo "${DKIM_sec}" | openssl rsa -pubout -outform PEM`
        DKIM_pub=`echo "${DKIM_pub}" | head -n -1 | tail -n +2 | tr -d '\n'`
        cat >${UMBRELLA_KEYS_XML} <<EOF
<Properties>
    <!-- *** Generated initially by the Umbrella Linux installer. *** -->

    <!-- This file contains various public and private keys.  -->
    <!-- Please keep it protected.                            -->
    <!-- It is also possible to store it encrypted and still have it -->
    <!-- usable by bcfg2. See the bcfg2 documentation on encrypting  -->
    <!-- Property files.                                             -->

    <!-- ssh keys, which can log in under root account -->
    <!-- key for root@vmhost (can be very useful in non LXD settings) -->
    <!-- <root_ssh_key>ssh-rsa AAAAB3Nza.......SQpMR root@vmhost</root_ssh_key> -->

    <!-- You may want to add admin ssh keys here after the admins find -->
    <!-- chance to log in and generate them.                           -->
    <!-- admin1 -->
    <!-- <root_ssh_key>ssh-rsa AAAAB3Nza.....zr6Q== admin1@host</root_ssh_key> -->

    <!-- OPTIONAL: public part of the ssh key for the root user on nfs server-->
    <!-- currently only used if exporting authentication to DMZ and user's   -->
    <!-- homepages in ~/public_html/ are enabled in firewall.xml .           -->
    <!-- The private key should be generated for root@'nfs' and should be    -->
    <!-- passwordless. It is used in ~/public_html/ directories replication  -->
    <!-- to DMZwww . -->
    <!-- <nfs_root_ssh_key>ssh-rsa AAAAB3Nza....a9K/h root@nfs</nfs_root_ssh_key> -->

    <!-- Public and private keys for DKIM signatures on outgoing mail.     -->
    <DKIMpubkey>${DKIM_pub}</DKIMpubkey>
    <DKIMseckey>${DKIM_sec}</DKIMseckey>

    <!-- The main SSL certificate authority, which signs all the          -->
    <!-- bcfg2-generated certificates                                     -->
    <!-- public key (certificate) -->
    <CA_pub>${CA_pub}</CA_pub>
    <!-- secret key -->
    <CA_sec>${CA_sec}</CA_sec>
    <!-- passphrase -->
    <CA_pass>${CA_pass}</CA_pass>

    <!-- root password for network-installed workstations in plain text -->
    <netinstall_root_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)</netinstall_root_pass>

    <!-- SNMPv3 password for nagios user -->
    <!-- ( must be longer than 8 characters ) -->
    <snmp_nagios_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)</snmp_nagios_pass>

    <!-- Global password for Bcfg2 authentication (hosts may have their  -->
    <!-- individual passwords, specified in clients.xml).                -->
    <bcfg2_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)</bcfg2_pass>

    <!-- bcfg2 reporting database -->
    <bcfg2_reports_db_name>bcfg2</bcfg2_reports_db_name>
    <bcfg2_reports_db_user>bcfg2</bcfg2_reports_db_user>
    <bcfg2_reports_db_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)</bcfg2_reports_db_pass>

    <!-- Spam Assasin database name, user and password -->
    <SA_db>spamassassin</SA_db>
    <SA_dbuser>spamassassin</SA_dbuser>
    <SA_dbpass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)</SA_dbpass>

    <!-- Root password for backups of MySQL server on config -->
    <MySQLbackuppass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)</MySQLbackuppass>

    <!-- MySQL password for zabbix database on config -->
    <MySQLzabbixpass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)</MySQLzabbixpass>

    <!-- master password for KRB5 database -->
    <KRB5_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 20 | head -n 1)</KRB5_pass>

    <!-- Password for the admin user of GOSA -->
    <GOSA_admin_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)</GOSA_admin_pass>

    <!-- root cn=admin,cn=config password to bind to cn=config -->
    <LDAP_config_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)</LDAP_config_pass>

    <!-- cn=syncrepl,(suffix) password for LDAP replication -->
    <LDAP_syncrepl_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1)</LDAP_syncrepl_pass>

    <!-- cn=admin,(suffix) root password for LDAP binds to (suffix) -->
    <LDAP_pass>$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)</LDAP_pass>
</Properties>
EOF
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

tmpfile=$(mktemp)
echo -n "Pulling data from umbrella_keys.xml... "; ( set -e; set -o xtrace;
    echo CA_pass=`xmllint --xpath '//Properties//CA_pass/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo bcfg2_pass=`xmllint --xpath '//Properties//bcfg2_pass/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo KRB5_pass=`xmllint --xpath '//Properties//KRB5_pass/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo LDAP_pass=`xmllint --xpath '//Properties//LDAP_pass/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo mysql_root_pass=`xmllint --xpath '//Properties//MySQLbackuppass/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo bcfg2_db_name=`xmllint --xpath '//Properties//bcfg2_reports_db_name/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo bcfg2_db_user=`xmllint --xpath '//Properties//bcfg2_reports_db_user/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo bcfg2_db_pass=`xmllint --xpath '//Properties//bcfg2_reports_db_pass/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo SA_db_name=`xmllint --xpath '//Properties//SA_db/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo SA_db_user=`xmllint --xpath '//Properties//SA_dbuser/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
    echo SA_db_pass=`xmllint --xpath '//Properties//SA_dbpass/text()' ${UMBRELLA_KEYS_XML}` >>${tmpfile}
) 2>&1 | log; check ${PIPESTATUS[0]}
source ${tmpfile}
rm -f ${tmpfile}

KRB5_CONFIG=${TMPINSTALLDIR}/krb5.conf
KRB5_KDC_PROFILE=${TMPINSTALLDIR}/kdc.conf
KRB5_KADM5_ACL=${TMPINSTALLDIR}/kadm5.acl
KRB5_STASH=${TMPINSTALLDIR}/stash
KRB5_DB=${TMPINSTALLDIR}/krb5kdc/principal
KRB5_FLAG=${FLAGSDIR}/.krb5_initialized
if [ ! -f "$KRB5_FLAG" ]; then
    echo -n "Feeding the entropy pool... "; ( set -e; set -o xtrace;
        wget -q -O - 'https://www.random.org/cgi-bin/randbyte?nbytes=2048&format=f' >/dev/urandom
    ) 2>&1 | log; check ${PIPESTATUS[0]}

    echo -n "Initializing kerberos... "; ( set -e; set -o xtrace;
        ${APT_GET_INSTALL} krb5-kdc krb5-admin-server
        rm -rf ${TMPINSTALLDIR}/krb5kdc
        mkdir -p ${TMPINSTALLDIR}/krb5kdc
        cat $UMBRELLADIR/Cfg/etc/krb5.conf/krb5.conf.genshi | \
            nanogenshi >"${KRB5_CONFIG}"
        cat $UMBRELLADIR/Cfg/etc/krb5kdc/kdc.conf/kdc.conf.genshi | \
            sed "s|/etc/krb5kdc/kadm5.acl|${KRB5_KADM5_ACL}|g" |
            sed "s|/etc/krb5kdc/stash|${KRB5_STASH}|g" |
            sed "s|/var/lib/krb5kdc/principal|${KRB5_DB}|g" |
            nanogenshi >"${KRB5_KDC_PROFILE}"
        echo "*/admin@${realm_name}      *" > "${KRB5_KADM5_ACL}"
        echo -e "${KRB5_pass}\n${KRB5_pass}" | kdb5_util -r ${realm_name} -d ${KRB5_DB} -sf ${KRB5_STASH} create -s

        KADMIN="kadmin.local -r ${realm_name} -d ${KRB5_DB} -m"

        # create the first admin user with the password '123'
        if ! ( echo "${KRB5_pass}" | ${KADMIN} -q listprincs | grep -q "^${first_admin}@") ; then
            echo "${KRB5_pass}" | ${KADMIN} -q "addprinc -randkey -clearpolicy \"${first_admin}\""
            echo "${KRB5_pass}" | ${KADMIN} -q "change_password -pw \"123\" \"${first_admin}\""
        fi

        # takes three parameters: keytab_path principal1 [principal 2 ...]
        function make_keytab {
            KEYTAB=$1
            shift
            TMPKEYTAB=$(mktemp)
            rm -f ${TMPKEYTAB}
            for PRINCIPAL in $@ ; do
                 echo ${PRINCIPAL}
                 echo "${KRB5_pass}" | ${KADMIN} -q "add_principal -randkey ${PRINCIPAL}"
                 echo "${KRB5_pass}" | ${KADMIN} -q "ktadd -k ${TMPKEYTAB} ${PRINCIPAL}"
            done
            mv ${TMPKEYTAB} ${UMBRELLADIR}/Cfg${KEYTAB}
        }

        make_keytab /etc/gosa/hostmanager.keytab/hostmanager.keytab.H_${config_hostname}.${domain_name} hostmanager/${config_hostname}.${domain_name}
        make_keytab /etc/apache2/http.keytab/http.keytab.H_${config_hostname}.${domain_name} HTTP/${config_hostname}.${domain_name}
        if [ -n "${monitor_hostname}" ]; then
            make_keytab /etc/apache2/http.keytab/http.keytab.H_${monitor_hostname}.${domain_name} HTTP/${monitor_hostname}.${domain_name}
        fi
        make_keytab /etc/ldap/slapd.keytab/slapd.keytab.H_${config_hostname}.${domain_name} ldap/${config_hostname}.${domain_name}
        if [ -n "${proxy_hostname}" ]; then
            make_keytab /etc/ldap/slapd.keytab/slapd.keytab.H_${proxy_hostname}.${domain_name} ldap/${proxy_hostname}.${domain_name}
            if [ -z "${xmpp_hostname}" ]; then
                make_keytab /etc/prosody/xmpp.keytab/xmpp.keytab.H_${proxy_hostname}.${domain_name} xmpp/${proxy_hostname}.${domain_name}
            fi
        fi
        if [ -n "${xmpp_hostname}" ]; then
            make_keytab /etc/prosody/xmpp.keytab/xmpp.keytab.H_${xmpp_hostname}.${domain_name} xmpp/${xmpp_hostname}.${domain_name}
        fi

        for host in ${allservers}; do
            host_fqdn=${host}.${domain_name}
            principals="host/${host_fqdn}"
            if [ -n "${nfs_hostname}" ]; then
                principals="${principals} nfs/${host_fqdn}"
            fi
            if [ "${host}" = "${mail_hostname}" ]; then
                principals="${principals} imap/${host_fqdn} smtp/${host_fqdn}"
            fi
            make_keytab /etc/krb5.keytab/krb5.keytab.H_${host_fqdn} ${principals}
        done
        touch "$KRB5_FLAG"
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

BCFG2_SERVER_CONF=${TMPINSTALLDIR}/bcfg2-server.conf
BCFG2_FLAG=${FLAGSDIR}/.bcfg2_initialized
if [ ! -f "$BCFG2_FLAG" ]; then
    echo -n "Initializing bcfg2... "; ( set -e; set -o xtrace;
        groupadd -g 999 bcfg2
        useradd -d /run/sshd -g bcfg2 -M -s /usr/sbin/nologin -u 999 bcfg2
        ${APT_GET_INSTALL} bcfg2-server git mc python3-passlib ssl-cert python3-pymysql

        # prepare bcfg2 config
        cat "${UMBRELLADIR}/Cfg/etc/bcfg2-server.conf/bcfg2-server.conf.G50_config.genshi" | \
            sed -e "s/,Reporting,/,/g" | \
            grep -v "\[reporting\]" | \
            grep -v "^transport =" | \
            grep -v "^web_prefix =" | \
            grep -v "^file_limit =" | \
            nanogenshi >${BCFG2_SERVER_CONF}

        # initialising Probes
        probes=`ls ${UMBRELLADIR}/Probes | grep -v '^probed.xml$'`
        probexml=${UMBRELLADIR}/Probes/probed.xml
        echo "<Probed>" >${probexml}
        for host in ${allservers}; do
            host_fqdn=${host}.${domain_name}
            echo "  <Client name=\"${host_fqdn}\" timestamp=\"1669814701\">" >>${probexml}
            for probe in ${probes}; do
                    echo "    <Probe name=\"${probe}\" value=\"\"/>" >>${probexml}
            done
            echo "    <Group name=\"amd64\"/>" >>${probexml}
            if [ ${host} = ${config_hostname} ]; then
                echo "    <Group name=\"local-bcfg2-rules-defined\"/>" >>${probexml}
            fi
            if [ ${host} = ${vmhost_hostname} ]; then
                echo "    <Group name=\"lvm\"/>" >>${probexml}
                echo "    <Group name=\"mdraid\"/>" >>${probexml}
            fi
            if [ ${host} = ${ltsp_hostname} ]; then
                echo "    <Group name=\"ntfs-3g\"/>" >>${probexml}
                echo "    <Group name=\"simple-scan\"/>" >>${probexml}
            fi
            echo "    <Group name=\"subpixel-unknown\"/>" >>${probexml}
            echo "    <Group name=\"ubuntu\"/>" >>${probexml}
            echo "    <Group name=\"ubuntu-jammy\"/>" >>${probexml}
            if [ ${host} = ${vmhost_hostname} ]; then
                echo "    <Group name=\"installation-in-progress\"/>" >>${probexml}
                echo "    <Group name=\"lxd-containers-defined\"/>" >>${probexml}
                hostvirt=$(systemd-detect-virt)
                if [ "${hostvirt}" = "none" ]; then
                    echo "    <Group name=\"physical\"/>" >>${probexml}
                else
                    echo "    <Group name=\"virt-${hostvirt}\"/>" >>${probexml}
                    echo "    <Group name=\"vm\"/>" >>${probexml}
                fi
            else
                echo "    <Group name=\"virt-lxc\"/>" >>${probexml}
                echo "    <Group name=\"vm\"/>" >>${probexml}
            fi
            echo "  </Client>" >>${probexml}
        done
        echo "</Probed>" >>${probexml}

        # initialising clients.xml
        clientsxml=${UMBRELLADIR}/Metadata/clients.xml
        echo "<Clients>" >${clientsxml}
        for func in ${allfunctions}; do
            if [[ "${func}" == DMZ* ]]; then
                hostnamevar="${func:3}_hostname"
                ipaddrvar="${func:3}_DMZ_ip"
            else
                hostnamevar="${func}_hostname"
                ipaddrvar="${func}_pub_ip"
            fi
            host=${!hostnamevar}
            host_fqdn=${host}.${domain_name}
            host_ip=${!ipaddrvar}
            echo -n "  <Client profile=\"${func}\" name=\"${host_fqdn}\" address=\"${host_ip}\" version=\"1.4.0pre2\"" >>${clientsxml}
            if [ "${func}" = "config" -o "${func}" = "proxy" -o "${func}" = "ltsp" ]; then
                echo ">" >>${clientsxml}
                if [ "${func}" = "config" ]; then
                    echo "    <Alias name=\"gosa.${domain_name}\"/>" >>${clientsxml}
                    echo "    <Alias name=\"kdc1.${domain_name}\"/>" >>${clientsxml}
                    echo "    <Alias name=\"ldap1.${domain_name}\"/>" >>${clientsxml}
                    echo "    <Alias name=\"autoconfig.${domain_name}\"/>" >>${clientsxml}
                    echo "    <Alias name=\"wpad.${domain_name}\"/>" >>${clientsxml}
                elif [ "${func}" = "proxy" ]; then
                    echo "    <Alias name=\"kdc2.${domain_name}\"/>" >>${clientsxml}
                    echo "    <Alias name=\"ldap2.${domain_name}\"/>" >>${clientsxml}
                elif [ "${func}" = "ltsp" ]; then
                    echo "    <Alias name=\"gate.${domain_name}\"/>" >>${clientsxml}
                else
                    exit 1 # should never be here
                fi
                echo "  </Client>" >>${clientsxml}
            else
                echo "/>" >>${clientsxml}
            fi
        done
        echo "  <!--PLACEHOLDER-->" >>${clientsxml}
        echo "</Clients>" >>${clientsxml}
        cp $xml_req_files ${UMBRELLADIR}/Properties/
        cp ${UMBRELLA_KEYS_XML} ${UMBRELLADIR}/Properties/
        cp ${KRB5_STASH} ${UMBRELLADIR}/Cfg/etc/krb5kdc/stash/stash

        if [ -d "${DEBS_OVERLAY}" ]; then
            cat >${UMBRELLADIR}/Packages/local-sources.xml <<EOF
<Sources>
    <Source type="apt" url="file://${DEBS_OVERLAY}">
      <Component>./</Component>
      <Arch>amd64</Arch>
    </Source>
</Sources>
EOF
        fi

        touch "$BCFG2_FLAG"
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

echo -n "Feeding the entropy pool... "; ( set -e; set -o xtrace;
    wget -q -O - 'https://www.random.org/cgi-bin/randbyte?nbytes=2048&format=f' >/dev/urandom
) 2>&1 | log; check ${PIPESTATUS[0]}

ALLCONFDIR="${TMPINSTALLDIR}/xml_configs"
echo -n "Generating configuration for all servers... "; ( set -e; set -o xtrace;
    # we actually do the build twice to have all generated keys distributed to
    # all servers.
    bcfg2-info -C ${TMPINSTALLDIR}/bcfg2-server.conf buildall ${ALLCONFDIR}
    bcfg2-info -C ${TMPINSTALLDIR}/bcfg2-server.conf buildall ${ALLCONFDIR}
) 2>&1 | log; check ${PIPESTATUS[0]}

ROOTKEY=/root/.ssh/id_rsa
if [ ! -f "${ROOTKEY}" ]; then
    echo -n "Feeding the entropy pool... "; ( set -e; set -o xtrace;
        wget -q -O - 'https://www.random.org/cgi-bin/randbyte?nbytes=2048&format=f' >/dev/urandom
    ) 2>&1 | log; check ${PIPESTATUS[0]}

    echo -n "Generating root ssh key without passphrase... "; ( set -e; set -o xtrace;
        rm -f "${ROOTKEY}" "${ROOTKEY}.pub"
        ssh-keygen -b 2048 -t rsa -f "${ROOTKEY}" -q -N ""
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

IMAGETAR=~/"$DISTRIB_CODENAME.tar"
IMAGEMETATAR=~/"$DISTRIB_CODENAME-metadata.tar.gz"
if [ ! -f "$IMAGETAR" -o ! -f "$IMAGEMETATAR" ]; then
    echo -n "Generating a base VM image... "; ( set -e; set -o xtrace;
        computecorrections() {
            # computes the sequence of renumberings to bring the identifiers in the
            # current name:id mappings, specified as the first argument, in line with
            # the desired global set of name:id mappings, specified as the second
            # argument. It is not necessary that all the names from the "desired"
            # list are present in the current mappings.
            # The result is the list of lines <name>:<oldid>:<name>:<newid> on stdout,
            # which describe the required set of renumberings in order.
            actualnameswithids=$1
            desirednameswithids=$2
            actualnames=$(cut -d ':' -f 1 <(echo "${actualnameswithids}") | sort)
            knownnames=$(cut -d ':' -f 1 <(echo "${desirednameswithids}") | sort)
            actualandknown=$(grep -xF -f <(echo "${actualnames}") <(echo "${knownnames}") | sort)
            if ! cmp -s <(echo "${actualnames}") <(echo "${actualandknown}") ; then
                # some names are unknown to Umbrella
                unknownnames=$(grep -vxF -f <(echo "${knownnames}") <(echo "${actualnames}") | sort)
                echo -e "\n\nThe following group/user names are unknown: ${unknownnames} . Please update the Umbrella Linux configuration.\n\n" 1>&2
                exit 9
            else
                # all names have IDs defined in Umbrella bundles
                correctnameswithids=$(grep -xF -f <(echo "${actualnameswithids}") <(echo "${desirednameswithids}"))
                needcorrection=$(grep -vxF -f <(echo "${correctnameswithids}") <(echo "${actualnameswithids}") | cut -d ':' -f 1)
                if [[ -n "$needcorrection" ]]; then
                    oldids=$(grep -wF -f <(echo "$needcorrection") <(echo "${actualnameswithids}"))
                    newids=$(grep -wF -f <(echo "$needcorrection") <(echo "${desirednameswithids}"))
                    corrections=$(paste <(echo "$oldids") <(echo "$newids") --delimiters ':')

                    # here we do the topological sorting (basically along the lines
                    # of the Kahn's algorithm)
                    while : ; do
                        targetid=$(cut -d ':' -f 4 <(echo "${corrections}") | sort)
                        srcid=$(cut -d ':' -f 2 <(echo "${corrections}") | sort)
                        freetargetid=$(grep -vxF -f <(echo "${srcid}") <(echo "${targetid}"))
                        [[ -z "$freetargetid" ]] && break;
                        grep  -wF -f <(echo "$freetargetid") <(echo "${corrections}")
                        corrections=$(grep  -vwF -f <(echo "$freetargetid") <(echo "${corrections}"))
                    done
                fi
                if [[ -n "$corrections" ]]; then
                    echo -e "\n\nRenumber graph contains loops: $corrections . Please introduce new Umbrella IDs manually to break them.\n\n" 1>&2
                    exit 9
                fi
            fi
            exit 0
        }

        pullnameswithids() {
            # pulls the set of desired name:id from the Umbrella configuration repo
            # the first argument is the tag, the second is the id attribute name.
            # Note that it does not fully account for the bcfg2 group memberships and
            # instead relies on a simple heuristic regarding the most basic groups
            # description in the Umbrella repository. Only these basic groups are
            # expected in the bare bones Ubuntu install on which this script operates.
            BUNDLESDIR="$UMBRELLADIR/Bundler"
            names=$(xmllint --xpath "/*/*/$1/@name" ${ALLCONFDIR}/*.xml 2>/dev/null | grep 'name=' | sed 's/ name="//g' | sed 's/"//g')
            ids=$(xmllint --xpath "/*/*/$1/@$2" ${ALLCONFDIR}/*.xml 2>/dev/null | grep "$2=" | sed "s/ $2=\"//g" | sed 's/"//g')
            paste <(echo "${names}") <(echo "${ids}") --delimiters ':' | sort -u
        }

        fixuidsandgids() {
            # fixes uids and gids in a system image, the first argument specifies
            # the root
            desiredusernameswithuids=$(pullnameswithids POSIXUser uid)
            actualusernameswithuids=$(cut -d ':' -f 1,3 $1/etc/passwd | sort)
            uidcorr=$(computecorrections "$actualusernameswithuids" "$desiredusernameswithuids")
            echo "$uidcorr" | \
            (
                IFS=':';
                while read -r name olduid name_dup newuid; do
                    if [[ "$name" != "$name_dup" ]]; then
                        echo -e "\n\nInternal error during uid matching.\n\n" 1>&2
                        exit 9
                    fi
                    perl -pi -e "s/^$name:x:$olduid/$name:x:$newuid/" "$1/etc/passwd"
                    chown --from=$olduid $newuid -R "$1"
                done
            )

            desiredgroupnameswithgids=$(pullnameswithids POSIXGroup gid)
            actualgroupnameswithgids=$(cut -d ':' -f 1,3 $1/etc/group | sort)
            gidcorr=$(computecorrections "$actualgroupnameswithgids" "$desiredgroupnameswithgids")
            echo "$gidcorr" | \
            (
                IFS=':';
                while read -r name oldgid name_dup newgid; do
                    if [[ "$name" != "$name_dup" ]]; then
                        echo -e "\n\nInternal error during gid matching.\n\n" 1>&2
                        exit 9
                    fi
                    sed -i "s/\([^:]*:x:[0-9]*:\)${oldgid}:/\1${newgid}:/g" $1/etc/passwd
                    perl -pi -e "s/^$name:x:$oldgid/$name:x:$newgid/" "$1/etc/group"
                    chown --from=:$oldgid :$newgid -R "$1"
                done
            )
        }

        TMPDISTDIR=$(mktemp -d)

        rm -rf $TMPDISTDIR

        # fix the eatmydata mmdebstrap hook (may be unnecesary in future)
        TMPEATMYDATAHOOKDIR=`mktemp -d`
        cp /usr/share/mmdebstrap/hooks/eatmydata/*.sh $TMPEATMYDATAHOOKDIR
        sed -i 's/SHA256/SHA512/g' $TMPEATMYDATAHOOKDIR/extract.sh

        # bootstrap the image
        mmdebstrap --hook-dir=$TMPEATMYDATAHOOKDIR --include=iptables \
            "$DISTRIB_CODENAME" "$TMPDISTDIR"

        fixuidsandgids "$TMPDISTDIR"
        chmod u+s "$TMPDISTDIR/usr/lib/dbus-1.0/dbus-daemon-launch-helper"

        # we also push the umbrella package sources here
        cp "$UMBRELLADIR/Cfg/etc/apt/sources.list/sources.list.G50_ubuntu-$DISTRIB_CODENAME" \
            "$TMPDISTDIR/etc/apt/sources.list"
        cp "$UMBRELLADIR/Cfg/etc/apt/sources.list.d/multiverse.list/multiverse.list.G50_ubuntu-$DISTRIB_CODENAME" \
           "$TMPDISTDIR/etc/apt/sources.list.d/multiverse.list"
        cp "$UMBRELLADIR/Cfg/etc/apt/sources.list.d/umbrella.list/umbrella.list.G50_ubuntu-$DISTRIB_CODENAME" \
           "$TMPDISTDIR/etc/apt/sources.list.d/umbrella.list"
        cp "$UMBRELLADIR/Cfg/etc/apt/trusted.gpg.d/umbrella.gpg/umbrella.gpg" \
           "$TMPDISTDIR/etc/apt/trusted.gpg.d/umbrella.gpg"

        # tar the image
        rm -rf "$IMAGETAR"
        pushd "$TMPDISTDIR" >/dev/null
        tar --sort=name --mtime=now --clamp-mtime --numeric-owner \
            --one-file-system --format=pax \
            --pax-option=exthdr.name=%d/PaxHeaders/%f,delete=atime,delete=ctime \
            --exclude=./dev --xattrs -cf "$IMAGETAR" .
        popd >/dev/null
        rm -rf "$TMPDISTDIR"

        # creating metadata tar
        TMPDISTDIR=$(mktemp -d)
        CURRDATE=`date +%s`
        pushd "$TMPDISTDIR">/dev/null
        cat >metadata.yaml <<EOF
architecture: x86_64
creation_date: $CURRDATE
properties:
  description: Ubuntu 22.04 LTS Intel 64bit base image for Umbrella Linux server
  os: Ubuntu
  release: jammy 22.04
EOF
        tar cvfz "$IMAGEMETATAR" metadata.yaml
        popd >/dev/null
        rm -rf "$TMPDISTDIR"

    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

if ! grep -q '# Umbrella Installer Bridges Defined' ${NETCONFFILE} 2>/dev/null; then
    echo -n "Creating network bridges... "; ( set -e; set -o xtrace;
        rm -f /etc/netplan/00-installer-config.yaml
        cat >${NETCONFFILE} <<EOF
# Umbrella Installer Bridges Defined 1
network:
  version: 2
  renderer: networkd
  ethernets:
    ${ext_if}:
      dhcp4: no
      optional: true
  bridges:
    ${ext_br}:
      interfaces:
        - ${ext_if}
      addresses:
        - ${ext_addr}/${ext_cidr}
      gateway4: ${ext_gateway}
      nameservers:
        search:
          - ${domain_name}
        addresses:
          - 8.8.8.8
          - 8.8.4.4
    ${pub_br}:
      interfaces: []
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
    ${sec_br}:
      interfaces: []
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
    ${DMZ_br}:
      interfaces: []
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
EOF
        netplan apply
        sleep 5   # wait for network to become configured
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

if [[ ! -f /etc/apparmor.d/lxc/lxc-umbrella-server ]]; then
    echo -n "Installing and initializing LXD... "; ( set -e; set -o xtrace;
        if ! getent group lxd &>/dev/null; then
            groupadd -g 660 lxd
        else
            groupmod -g 660 lxd
        fi
        if ! getent passwd _lxd &>/dev/null; then
            useradd -d /var/lib/lxd/ -g lxd -m -s /bin/false -u 660 _lxd
        else
            usermod -u 660 _lxd
        fi
        ${APT_GET_INSTALL} lxd lxd-client lxd-tools
        ${APT_GET_INSTALL} ebtables xdelta3 iptables
        lxd init --minimal
        # delete unnecessary bridge
        lxc profile edit default <<EOF
config: {}
description: Default LXD profile
devices:
  root:
    path: /
    pool: default
    type: disk
name: default
used_by: []
EOF
        lxc network delete lxdbr0 || true # does not delete on the 1st attempt
        lxc network delete lxdbr0

        # root needs to have assigned subuid and subgid ranges
        cp ${UMBRELLADIR}/Cfg/etc/subuid/subuid /etc/subuid
        cp ${UMBRELLADIR}/Cfg/etc/subgid/subgid /etc/subgid

        # we also disable and mask waiting for network devices to become online
        rm -f /etc/systemd/system/systemd-networkd-wait-online.service
        ln -s /dev/null /etc/systemd/system/systemd-networkd-wait-online.service

        # import the base image
        lxc image import $IMAGEMETATAR $IMAGETAR --alias umbrella

        # allow more mounting possibilities
        cp ${UMBRELLADIR}/Cfg/etc/apparmor.d/lxc/lxc-umbrella-server/lxc-umbrella-server \
           /etc/apparmor.d/lxc/lxc-umbrella-server
        systemctl reload apparmor.service
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

# create_profile <subnet_name ("pub", "sec", "DMZ")> | router
create_profile() {
    subnet=$1
    if [ "${subnet}" = "router" ]; then
        profilename="router"
    else
        profilename=${subnet}srv
        bridgevar="${subnet}_br"
        bridge=${!bridgevar}
    fi
    if [[ ! $(lxc profile list) =~ "${profilename}" ]]; then
        echo -n "Creating \"${profilename}\" lxc profile... "; ( set -e; set -o xtrace;
            lxc profile create "${profilename}"
            lxc profile device add "${profilename}" root disk path=/ pool=default
            if [ "${subnet}" = "router" ]; then
                lxc network attach-profile ${ext_br} "${profilename}" ${router_ext_dev}
                lxc network attach-profile ${pub_br} "${profilename}" ${router_pub_dev}
                lxc network attach-profile ${sec_br} "${profilename}" ${router_sec_dev}
                lxc network attach-profile ${DMZ_br} "${profilename}" ${router_DMZ_dev}
            else
                lxc network attach-profile ${bridge} $profilename eth0
            fi
            lxc profile set ${profilename} raw.lxc lxc.apparmor.profile=lxc-umbrella-server
            lxc profile set ${profilename} security.privileged false
            if [ "${subnet}" = "pub" -o "${subnet}" = "router" ]; then
                lxc profile set ${profilename} raw.idmap 'both 1000-50999 1000-50999'
            fi
        ) 2>&1 | log; check ${PIPESTATUS[0]}
    fi
}

# create_vm <function>
create_vm() {
    func=$1
    if [ "${func}" = "router" ]; then
        funcname="${func}"
        subnet="${func}"
    elif [[ "${func}" == DMZ* ]]; then
        funcname="${func:3}"
        subnet="DMZ"
    else
        funcname="${func}"
        subnet="pub"
    fi
    hostnamevar="${funcname}_hostname"
    hostname="${!hostnamevar}"
    hostFQDN="${hostname}.${domain_name}"

    if [ "${subnet}" = "router" ]; then
        profilename="router"
    else
        profilename="${subnet}srv"
    fi
    if [[ -n "${hostname}" && ! "$(lxc list -c n -f csv)" =~ "${hostname}" ]]; then
        echo -n "Creating and starting \"${hostname}\"... "; ( set -e; set -o xtrace;
            lxc init umbrella -p "${profilename}" "${hostname}"

            # set interface names and MAC addresses
            if [ "${func}" = "router" ]; then
                lxc config set "${hostname}" \
                    volatile.${router_ext_dev}.name "${router_ext_dev}"
                lxc config set "${hostname}" \
                    volatile.${router_ext_dev}.hwaddr "${router_ext_mac}"
                lxc config set "${hostname}" \
                    volatile.${router_pub_dev}.name "${router_pub_dev}"
                lxc config set "${hostname}" \
                    volatile.${router_pub_dev}.hwaddr "${router_pub_mac}"
                lxc config set "${hostname}" \
                    volatile.${router_sec_dev}.name "${router_sec_dev}"
                lxc config set "${hostname}" \
                    volatile.${router_sec_dev}.hwaddr "${router_sec_mac}"
                lxc config set "${hostname}" \
                    volatile.${router_DMZ_dev}.name "${router_DMZ_dev}"
                lxc config set "${hostname}" \
                    volatile.${router_DMZ_dev}.hwaddr "${router_DMZ_mac}"
            else
                ipvar="${funcname}_${subnet}_ip"
                ip="${!ipvar}"
                netmaskvar="${subnet}_netmask"
                netmask="${!netmaskvar}"
                cidrvar="${subnet}_cidr"
                cidr="${!cidrvar}"
                gateway_ipvar="router_${subnet}_ip"
                gateway_ip=${!gateway_ipvar}
                macvar="${funcname}_${subnet}_mac"
                mac="${!macvar}"
                devvar="${funcname}_${subnet}_dev"
                dev="${!devvar}"
                lxc config set "${hostname}" volatile.eth0.name "${dev}"
                lxc config set "${hostname}" volatile.eth0.hwaddr "${mac}"
            fi
            if [ "${func}" = "backdoor" ]; then
                # for the backdoor server we need to add another interface
                lxc config device add "${hostname}" eth1 nic name=eth1 nictype=bridged parent=${ext_br}
                lxc config set "${hostname}" volatile.eth1.name "${backdoor_ext_dev}"
                lxc config set "${hostname}" volatile.eth1.hwaddr "${backdoor_ext_mac}"
            fi
            if [ "${func}" = "nfs" ]; then
                # nfs is the only privileged container, which is required
                # to run nfsv4 kernel server
                lxc config set "${hostname}" security.privileged true
            fi
            if [ "${func}" = "ltsp" ]; then
                # mknod is required to create x2go thin client chroot
                lxc config set "${hostname}" security.syscalls.intercept.mknod true
            fi

            # boot priorities for LXD containers with specific function
            declare -A priorities
            priorities[router]=10
            priorities[config]=9
            priorities[proxy]=8
            priorities[nfs]=7
            priorities[mail]=6
            priorities[ltsp]=5
            priorities[monitor]=4
            priorities[backdoor]=1
            priorities[DMZsmtp]=3
            priorities[DMZwww]=2
            priorities[DMZxmpp]=2
            priorities[DMZpbx]=2
            priorities[DMZvpn]=2

            lxc config set "${hostname}" boot.autostart 1
            lxc config set "${hostname}" boot.autostart.delay 30
            lxc config set "${hostname}" boot.autostart.priority "${priorities[$func]}"

            # push hostname
            echo "${hostname}" | lxc file push - ${hostname}/etc/hostname

            # push network configuration
            if [ "${func}" = "router" ]; then
                lxc file push - ${hostname}/etc/netplan/01-netcfg.yaml <<EOF
network:
  version: 2
  renderer: networkd
  ethernets:
    ${router_ext_dev}:
      addresses:
        - ${ext_addr}/${ext_cidr}
      nameservers:
        search:
          - ${domain_name}
        addresses:
          - 8.8.8.8
          - 8.8.4.4
      routes:
        - to: default
          via: ${ext_gateway}
    ${router_pub_dev}:
      addresses:
        - ${router_pub_ip}/${pub_cidr}
    ${router_sec_dev}:
      addresses:
        - ${router_sec_ip}/${sec_cidr}
    ${router_DMZ_dev}:
      addresses:
        - ${router_DMZ_ip}/${DMZ_cidr}
EOF
                # push /etc/rc.local
                lxc file push - ${hostname}/etc/rc.local --mode=0755 <<EOF
#!/bin/bash

# enable IP forwarding and masquerading
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -t nat -A POSTROUTING -o ${router_ext_dev} -j MASQUERADE

# forward incoming ssh connection to vhost
# This forwarding will be erased once bcfg2 kicks in on router,
# but is convenient for debugging the installer.
iptables -t nat -A PREROUTING -i ${router_ext_dev} -p tcp --dport 22 -j DNAT \
      --to ${vmhost_pub_ip}:22
EOF
            else
                dns_server_ip=${gateway_ip}
                if [ "${subnet}" = "DMZ" ]; then
                    if [ "${func}" = "DMZsmtp" ]; then
                        # we use Google DNS, since it is allowed through
                        # firewall on DMZsmtp
                        dns_server_ip="8.8.8.8"
                    else
                        # we use DMZsmtp for name resolution
                        dns_server_ip="${smtp_DMZ_ip}"
                    fi
                fi
                lxc file push - ${hostname}/etc/netplan/01-netcfg.yaml <<EOF
network:
  version: 2
  renderer: networkd
  ethernets:
    ${dev}:
      dhcp4: no
      addresses:
        - ${ip}/${cidr}
      nameservers:
        search:
          - ${domain_name}
        addresses:
          - ${dns_server_ip}
      routes:
        - to: default
          via: ${gateway_ip}
EOF
            fi

            if [ "${subnet}" == "DMZ" ]; then
                # DMZ has no internet access, we rely both on hosts and DMZsmtp
                # to resolve hostnames. The hosts file is necessary to resolve
                # the most important internal servers at least.
                lxc file push - ${hostname}/etc/hosts <<EOF
# minimal hosts file, just to survive before the real one is installed by bcfg2
127.0.0.1        localhost localhost.${domain_name}
127.0.0.1 localhost
::1 ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts
${router_DMZ_ip}        ${router_hostname}.${domain_name} ${router_hostname} ns1.${domain_name} ns1
${config_pub_ip}        ${config_hostname}.${domain_name} ${config_hostname} kdc1.${domain_name} kdc1 ldap1.${domain_name} ldap1 autoconfig.${domain_name} autoconfig gosa.${domain_name} gosa wpad.${domain_name} wpad
${proxy_pub_ip}         ${proxy_hostname}.${domain_name} ${proxy_hostname} kdc2.${domain_name} kdc2 ldap2.${domain_name} ldap2
EOF
                # it is also crucial that we use the proxy server in DMZ,
                # otherwise no packages can be downloaded. We also address
                # proxy by IP here to avoid DNS lookups by APT at this stage
                lxc file push - ${hostname}/etc/apt/apt.conf.d/99proxy <<EOF
Acquire::http { Proxy "http://${proxy_pub_ip}:3142"; };
Acquire::https { Proxy "http://${proxy_pub_ip}:3142"; };
EOF
            fi

            lxc start ${hostname}
            sleep 10
        ) 2>&1 | log; check ${PIPESTATUS[0]}
    fi
}

config_vm() {
    func=$1
    if [[ "${func}" == DMZ* ]]; then
        hostnamevar="${func:3}_hostname"
    else
        hostnamevar="${func}_hostname"
    fi
    hostname=${!hostnamevar}
    hostFQDN=${hostname}.${domain_name}
    flag=${FLAGSDIR}/.configured_${func}

    # here are the things we do even if the host is already configured
    if [ "${func}" = "config" ]; then
        echo -n "Copying Umbrella bcfg2 repository over to ${hostname}... "; ( set -e; set -o xtrace;
            # copy the bcfg2 repository
            lxc file push -rp ${UMBRELLADIR} ${hostname}/var/lib/
            lxc exec ${hostname} -- chown -R 1100:999 /var/lib/bcfg2
            lxc exec ${hostname} -- chmod -R g+rwX /var/lib/bcfg2
            lxc exec ${hostname} -- find /var/lib/bcfg2 -type d -exec chmod g+s '{}' \;
        ) 2>&1 | log; check ${PIPESTATUS[0]}
    fi

    if [ -e "${flag}" ]; then
        return 0
    fi

    echo -n "Configuring ${hostname}... "; ( set -e; set -o xtrace;
        if [ -d "${DEBS_OVERLAY}" ]; then
            if ! (lxc config device show ${hostname} | grep -q /root/debs); then
                lxc config device add ${hostname} debs \
                    disk source=${DEBS_OVERLAY} path=/root/debs
            fi
            echo "deb [trusted=yes] file:///root/debs ./" | \
                lxc file push - ${hostname}/etc/apt/sources.list.d/debs.list
        fi

        # link user homes to host
        if [[ ! "${func}" == DMZ* ]]; then
            if ! (lxc config device show ${hostname} | grep -q /nfs/${system_name}); then
                lxc exec ${hostname} -- mkdir -p /nfs/${system_name}
                lxc config device add ${hostname} homes disk source=/home path=/nfs/${system_name}
            fi
            if [ "${func}" = "nfs" ]; then
                if ! (lxc config device show ${hostname} | grep -q /export/home); then
                    lxc exec ${hostname} -- mkdir -p /export/home
                    lxc config device add ${hostname} exports disk source=/home path=/export/home
                fi
            fi
        fi

        if [ "${func}" = "router" -o "${func}" = "config" -o "${func}" = "proxy" ]; then
            lxc file push - ${hostname}/etc/apt/apt.conf.d/99zproxy <<EOF
# Disabling the APT proxy during the install.
# Please remove this file afterwards.
Acquire::http::Proxy "false";
EOF
        fi

        lxc file push ${ALLCONFDIR}/${hostFQDN}.xml ${hostname}/tmp/bcfg2conf.xml

        lxc file push - ${hostname}/etc/bcfg2.conf <<EOF
[client]
drivers=POSIXUsers,APT,VCS,Action,POSIX,Systemd

[POSIXUsers]
uid_blacklist=1000-
gid_blacklist=1000-
EOF

        lxc exec ${hostname} -- apt-get update
        lxc exec ${hostname} -- apt-get install eatmydata --no-install-recommends --assume-yes
        lxc exec ${hostname} -- ${APT_GET_INSTALL} bcfg2

        # install system users
        lxc exec ${hostname} -- systemctl stop systemd-networkd
        lxc exec ${hostname} -- systemctl stop systemd-resolved
        lxc exec ${hostname} -- ${BCFG2} -qv -D POSIXUsers -f /tmp/bcfg2conf.xml
        lxc exec ${hostname} -- systemctl restart systemd-networkd
        lxc exec ${hostname} -- systemctl restart systemd-resolved

        # install package sources and set apt options
        lxc exec ${hostname} -- ${BCFG2} -Qqv -b apt-sources -f /tmp/bcfg2conf.xml

        if [ "$func" = "config" ]; then
            # copy the CA
            lxc file push -p ${TMPINSTALLDIR}/openssl.cnf \
                ${hostname}/etc/pki/
            lxc file push -p ${TMPINSTALLDIR}/.rnd  \
                ${hostname}/etc/pki/ --mode=660 --uid=999 --gid=999
            lxc file push -r ${TMPINSTALLDIR}/CA \
                ${hostname}/etc/pki/
            lxc exec ${hostname} -- chgrp -R bcfg2 /etc/pki
            lxc exec ${hostname} -- chmod -R g+w /etc/pki
            lxc exec ${hostname} -- /bin/bash -c 'chmod -R o-rwx /etc/pki/CA/index* /etc/pki/CA/serial* /etc/pki/CA/newcerts /etc/pki/CA/private'

            # copy the Kerberos database
            lxc file push -rp ${TMPINSTALLDIR}/krb5kdc ${hostname}/var/lib/
            lxc file push -p ${TMPINSTALLDIR}/kadm5.acl ${hostname}/etc/krb5kdc/kadm5.acl
            lxc file push -p ${TMPINSTALLDIR}/stash ${hostname}/etc/krb5kdc/stash

            # initialize bcfg2 reporting database
            lxc exec ${hostname} -- ${BCFG2} -Qqv -b mysql-server -f /tmp/bcfg2conf.xml
            no_mysql_root_pass=$(lxc exec ${hostname} -- mysql -u root -sN \
                -e "SELECT authentication_string='' FROM mysql.user WHERE user='root';" || true)
            if [ "${no_mysql_root_pass}" = "1" ]; then
                # lxc exec ${hostname} -- "mysqladmin -u root password \"${mysql_root_pass}\""
                lxc exec ${hostname} -- mysql -u root <<EOF
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password by '${mysql_root_pass}';
EOF
            fi
            bcfg2_config_mysql_user=$(lxc exec ${hostname} -- \
                mysql -u root "-p${mysql_root_pass}" -sN -e \
                "SELECT 1 FROM mysql.user WHERE user='bcfg2' AND host='localhost'")
            if [ ! "${bcfg2_config_mysql_user}" = "1" ]; then
                lxc exec ${config_hostname} --  /bin/bash -c \
                    "mysql -u root \"-p${mysql_root_pass}\"" <<EOF
CREATE DATABASE ${bcfg2_db_name} DEFAULT CHARSET utf8 DEFAULT COLLATE utf8_general_ci;
CREATE USER ${bcfg2_db_user}@localhost IDENTIFIED BY '${bcfg2_db_pass}';
GRANT ALL ON ${bcfg2_db_name}.* TO ${bcfg2_db_user}@localhost;
FLUSH PRIVILEGES;
EOF
                fi
            if [ -n "${monitor_hostname}" ]; then
                bcfg2_monitor_mysql_user=$(lxc exec ${hostname} -- \
                    mysql -u root "-p${mysql_root_pass}" -sN -e \
                    "SELECT 1 FROM mysql.user WHERE user='bcfg2' AND host='${monitor_hostname}.${domain_name}'")
                if [ ! "${bcfg2_monitor_mysql_user}" = "1" ]; then
                    lxc exec ${config_hostname} --  /bin/bash -c \
                        "mysql -u root \"-p${mysql_root_pass}\"" <<EOF
CREATE USER ${bcfg2_db_user}@\`${monitor_hostname}.${domain_name}\` IDENTIFIED BY '${bcfg2_db_pass}';
GRANT ALL ON ${bcfg2_db_name}.* TO ${bcfg2_db_user}@\`${monitor_hostname}.${domain_name}\`;
FLUSH PRIVILEGES;
EOF
                fi
            fi

        fi
        if [ "$func" = "config" -o "$func" = "proxy" ]; then
            # initialize LDAP
            lxc exec ${hostname} -- ${BCFG2} -Qqv -b ca-certificates:ldap-server -f /tmp/bcfg2conf.xml
            lxc exec ${hostname} -- systemctl stop slapd
            lxc exec ${hostname} -- bash -c "rm -rf /var/lib/ldap/*"
            yes | lxc exec ${hostname} -- ldap-umbrella-init
            lxc exec ${hostname} -- systemctl start slapd
        fi

        lxc exec ${hostname} -- ${BCFG2} -qvk -r packages -f /tmp/bcfg2conf.xml

        if [ "${func}" = "ltsp" ]; then
            # initialize x2go thin client
            lxc exec "${hostname}" -- \
                /usr/local/bin/umbrella-reinit-x2gothinclient
        fi

        if [ "$func" = "DMZsmtp" ]; then
            # reconfigure router to send DNS queries through DMZsmtp
            lxc exec ${router_hostname} -- ${BCFG2} -qv -f /tmp/bcfg2conf.xml
        fi

        if [ "$func" = "mail" ]; then
            spamassassin_config_mysql_user=$(lxc exec ${config_hostname} -- \
                mysql -u root "-p${mysql_root_pass}" -sN -e \
                "SELECT 1 FROM mysql.user WHERE user='${SA_db_user}' AND host='${mail_hostname}.${domain_name}'")
            if [ ! "${spamassassin_config_mysql_user}" = "1" ]; then
                lxc exec ${config_hostname} --  /bin/bash -c \
                    "mysql -u root \"-p${mysql_root_pass}\"" <<EOF
CREATE DATABASE ${SA_db_name} DEFAULT CHARSET utf8 DEFAULT COLLATE utf8_general_ci;
EOF
                # get the sql definitions
                lxc file pull \
                    ${mail_hostname}/usr/share/doc/spamassassin/sql/awl_mysql.sql \
                    ${mail_hostname}/usr/share/doc/spamassassin/sql/bayes_mysql.sql \
                    ${mail_hostname}/usr/share/doc/spamassassin/sql/txrep_mysql.sql \
                    ${mail_hostname}/usr/share/doc/spamassassin/sql/userpref_mysql.sql \
                    /tmp/

                # fix
                perl -pi -e 's/TYPE=MyISAM/ENGINE=InnoDB/g' /tmp/userpref_mysql.sql

                # initialize the DB
                lxc exec ${config_hostname} --  /bin/bash -c \
                    "mysql -u root \"-p${mysql_root_pass}\" ${SA_db_name}" </tmp/awl_mysql.sql
                lxc exec ${config_hostname} --  /bin/bash -c \
                    "mysql -u root \"-p${mysql_root_pass}\" ${SA_db_name}" </tmp/bayes_mysql.sql
                lxc exec ${config_hostname} --  /bin/bash -c \
                    "mysql -u root \"-p${mysql_root_pass}\" ${SA_db_name}" </tmp/txrep_mysql.sql
                lxc exec ${config_hostname} --  /bin/bash -c \
                    "mysql -u root \"-p${mysql_root_pass}\" ${SA_db_name}" </tmp/userpref_mysql.sql

                # create spamassassin user
                lxc exec ${config_hostname} --  /bin/bash -c \
                    "mysql -u root \"-p${mysql_root_pass}\"" <<EOF
CREATE USER ${SA_db_user}@\`${mail_hostname}.${domain_name}\` IDENTIFIED BY '${SA_db_pass}';
GRANT ALL ON ${SA_db_name}.* TO ${SA_db_user}@\`${mail_hostname}.${domain_name}\`;
FLUSH PRIVILEGES;
EOF
            fi
        fi

        if [ "$func" = "config" ]; then
            # download the Ubuntu installer live image and extract some files
            lxc exec ${hostname} -- \
                /usr/local/bin/umbrella-maintain-installer-image
        fi

        if [ "$func" = "nfs" ]; then
            # explicitly unpack the skel image
            lxc exec ${hostname} -- rm -rf /var/lib/umbrella-skel/unpacked
            lxc exec ${hostname} -- bash -lc '/etc/cron.hourly/umbrella-skel'

            # and delete here the admin homes to have them recreated later with
            # properly unpacked skel.
            for admin in ${all_admins}; do
                lxc exec ${hostname} -- rm -rf "/export/home/${admin}"
            done
        fi

        if [ "$func" = "router" ]; then
            lxc exec ${hostname} -- sed -i '/forwarders/d' /etc/bind/named.conf.options
            lxc exec ${hostname} -- systemctl restart named
        fi

        touch "${flag}"
    ) 2>&1 | log; check ${PIPESTATUS[0]}
}

create_and_configure_vm() {
    func=$1
    if [[ "${func}" == DMZ* ]]; then
        hostnamevar="${func:3}_hostname"
    else
        hostnamevar="${func}_hostname"
    fi
    hostname="${!hostnamevar}"
    if [ -n "${hostname}" ]; then
        create_vm "$1"
        config_vm "$1"
    fi
}

create_profile "router"

create_vm "router"

if grep -q '# Umbrella Installer Bridges Defined 1' ${NETCONFFILE}; then
    echo -n "Reconfiguring the host's network to route via the router... "; ( set -e; set -o xtrace;
        cat >${NETCONFFILE} <<EOF
# Umbrella Installer Bridges Defined 2
network:
  version: 2
  renderer: networkd
  ethernets:
    ${ext_if}:
      macaddress: ${vmhost_ext_mac}
      dhcp4: no
      optional: true
  bridges:
    ${ext_br}:
      interfaces:
        - ${ext_if}
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
    ${pub_br}:
      addresses:
        - ${vmhost_pub_ip}/${pub_cidr}
      gateway4: ${router_pub_ip}
      nameservers:
        search:
          - ${domain_name}
        addresses:
          - 8.8.8.8
          - 8.8.4.4
    ${sec_br}:
      interfaces: []
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
    ${DMZ_br}:
      interfaces: []
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
EOF
        netplan apply
        sleep 10   # wait for network to become configured
    ) 2>&1 | log; check ${PIPESTATUS[0]}

    echo -n "Checking Internet connectivity... "; ( set -e; set -o xtrace;
        wget -qO- --tries=10 --timeout=20 --spider http://ru.archive.ubuntu.com >/dev/null
    ) 2>&1 | log; check ${PIPESTATUS[0]} "\nIn some cases (like running inside VirtualBox), a failure here is expected.\nIn this case just power down the VM (simple reboot will not be sufficient),\nstart it again and run the installer once more.\n"
fi

config_vm "router"

if grep -q '# Umbrella Installer Bridges Defined 2' ${NETCONFFILE}; then
    echo -n "Reconfiguring the host to use DNS on router... "; ( set -e; set -o xtrace;
    cat >${NETCONFFILE} <<EOF
# Umbrella Installer Bridges Defined 3
network:
  version: 2
  renderer: networkd
  ethernets:
    ${ext_if}:
      macaddress: ${vmhost_ext_mac}
      dhcp4: no
      optional: true
  bridges:
    ${ext_br}:
      interfaces:
        - ${ext_if}
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
    ${pub_br}:
      addresses:
        - ${vmhost_pub_ip}/${pub_cidr}
      gateway4: ${router_pub_ip}
      nameservers:
        search:
          - ${domain_name}
        addresses:
          - ${router_pub_ip}
    ${sec_br}:
      interfaces: []
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
    ${DMZ_br}:
      interfaces: []
      optional: true
      dhcp4: no
      dhcp6: no
      accept-ra: no
EOF
    netplan apply
    sleep 5
    ) 2>&1 | log; check ${PIPESTATUS[0]}

    echo -n "Checking Internet connectivity... "; ( set -e; set -o xtrace;
        wget -qO- --tries=10 --timeout=20 --spider http://ru.archive.ubuntu.com >/dev/null
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

create_profile pub
create_profile sec
create_profile DMZ
create_and_configure_vm "config"
create_and_configure_vm "proxy"

# now that proxy is "up" we can start using APT cache
lxc file delete ${router_hostname}/etc/apt/apt.conf.d/99zproxy &>/dev/null
lxc file delete ${config_hostname}/etc/apt/apt.conf.d/99zproxy &>/dev/null
lxc file delete ${proxy_hostname}/etc/apt/apt.conf.d/99zproxy &>/dev/null

create_and_configure_vm "nfs"
create_and_configure_vm "mail"
create_and_configure_vm "ltsp"
create_and_configure_vm "monitor"
create_and_configure_vm "backdoor"
create_and_configure_vm "DMZsmtp"
create_and_configure_vm "DMZwww"
create_and_configure_vm "DMZxmpp"
create_and_configure_vm "DMZvpn"

vmhost_flag=${FLAGSDIR}/.configured_vmhost
if [ ! -e "${vmhost_flag}" ]; then
    echo -n "Configuring ${vmhost_hostname}... "; ( set -e; set -o xtrace;
        cp ${ALLCONFDIR}/${vmhost_hostname}.${domain_name}.xml /tmp/bcfg2conf.xml
        cat >${hostname}/etc/bcfg2.conf <<EOF
[client]
drivers=POSIXUsers,APT,VCS,Action,POSIX,Systemd

[POSIXUsers]
uid_blacklist=1000-
gid_blacklist=1000-
EOF
        # remove some previously installed packages
        ${APT_GET_PURGE} krb5-admin-server krb5-kdc

        # remove extra packages (and, most importantly here, their users)
        ${APT_GET_PURGE} systemd-timesyncd virtualbox-guest-utils usbmuxd
        getent passwd usbmux &>/dev/null && userdel usbmux

        # install users
        systemctl stop systemd-networkd
        systemctl stop systemd-resolved
        systemctl stop dnsmasq
        ${BCFG2} -qv -D POSIXUsers -f /tmp/bcfg2conf.xml
        systemctl restart systemd-networkd
        systemctl restart systemd-resolved
        systemctl start dnsmasq

        # install package sources and set apt options
        ${BCFG2} -Qqv -b apt-sources -f /tmp/bcfg2conf.xml

        # configure the rest (bulk) of the system
        ${BCFG2} -qvk -r packages -f /tmp/bcfg2conf.xml
        ${BCFG2} -qvk -r packages -f /tmp/bcfg2conf.xml

        touch "${vmhost_flag}"
    ) 2>&1 | log; check ${PIPESTATUS[0]}
fi

fold -s -w 79 <<EOF
-----------------------------------------------------------------------
Installation is now complete.

Please reboot the system.

Your administrative credentials: login "${first_admin}", password "123".

Please do not forget to change the password immediately after your first login.

You can log in on console, or via SSH on port 22 of the external address ${ext_addr}, or from the internal "public" network by doing "ssh ${ltsp_hostname}".

There are three possibilities to get a GUI:
1. Connect using X2Go client to the external address or to ${ltsp_hostname}. When creating a new X2Go connection, please select a "Custom desktop" type and specify the command "umbrella-session" without quotes.
2. You can boot an X86 PC on a public network via PXE and select the "run terminal" option in boot menu. This option is selected by default and will be automatically enacted after a timeout. This will not make any changes on the permanent storage of that PC.
3. (if you logged via one of the previous options or via the command line and registered the wokstation MAC address in LDAP) You can boot an X86 PC on a public network via PXE and select an option to install an Umbrella workstation there. This will reformat the hard drive, erasing all the stored information. After the installation you can log in to that workstation in GUI mode.

Once you log in with administrative credentials, you can register more hosts and users by going to https://${config_hostname}.${domain_name}/ . You can also register new hosts by running a command "umbrella-addworkstation" as root on your configuration server "${config_hostname}".

You can check the status of all the Umbrella Linux servers and the status of their configuration at https://${monitor_hostname}.${domain_name}/ .
EOF
